<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Behind the Headlines: A Visual Journey into Media Bias</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Importmap to load the D3.js ES module -->
  <script type="importmap">
    {
      "imports": {
        "d3": "https://esm.run/d3@7"
      }
    }
  </script>
  <style>
    /* Global Styles */
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f4f4f4;
      color: #333;
      overflow-x: hidden;
      scroll-behavior: smooth;
    }

    section {
      padding: 100px 20px;
      opacity: 0;
      transform: translateY(50px);
      transition: opacity 0.8s ease-out, transform 0.8s ease-out;
    }

    section.visible {
      opacity: 1;
      transform: translateY(0);
    }

    h1,
    h2 {
      text-align: center;
      margin-bottom: 30px;
    }

    p {
      text-align: center;
      max-width: 800px;
      margin: 0 auto 20px;
      line-height: 1.6;
    }

    .scroll-down {
      text-align: center;
      font-size: 24px;
      margin-top: 30px;
      cursor: pointer;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }

      40% {
        transform: translateY(10px);
      }

      60% {
        transform: translateY(5px);
      }
    }

    /* Intro Section */
    #intro {
      position: relative;
      height: 100vh;
      background: #ffffff url('https://via.placeholder.com/1500x1000') no-repeat center;
      background-size: cover;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    #intro h1 {
      font-size: 3em;
      margin-bottom: 20px;
    }

    #stats-counters {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 20px 0;
    }

    .counter {
      background: rgba(255, 255, 255, 0.8);
      padding: 15px 20px;
      border-radius: 5px;
      font-size: 1.2em;
    }

    /* Chart Containers */
    .chart-container {
      width: 90%;
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    
    .dual-chart-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      width: 95%;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .chart-panel {
      flex: 1;
      min-width: 400px;
      background: white;
      border-radius: 5px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }

    /* Summary Section */
    #summary blockquote {
      font-style: italic;
      text-align: center;
      max-width: 600px;
      margin: 20px auto;
      color: #555;
    }

    #summary button {
      display: block;
      margin: 30px auto;
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
      background-color: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
    }

    /* Tooltip Styling */
    .tooltip {
      position: absolute;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
    }
    
    .distribution-bar {
      fill: #4e79a7;
    }
    
    .distribution-bar:hover {
      fill: #f28e2b;
    }
    
    .selected-circle {
      stroke-width: 3px;
      stroke: #000;
    }
    
    .distribution-label {
      font-size: 12px;
      fill: #333;
    }
    
    .distribution-title {
      font-size: 16px;
      font-weight: bold;
      text-anchor: middle;
    }
    
    .treemap-label {
      font-size: 10px;
      fill: white;
    }
  </style>
</head>

<body>
  <!-- Intro Section (Pinned Fullscreen) -->
  <section id="intro" class="visible">
    <h1>Behind the Headlines: A Visual Journey into Media Bias</h1>
    <div id="stats-counters">
      <div class="counter" id="total-articles">Articles: <span>0</span></div>
      <div class="counter" id="total-stories">Stories: <span>0</span></div>
      <div class="counter" id="num-sources">Sources: <span>0</span></div>
    </div>
    <p>Using a dataset of thousands of news stories, we uncover how bias and ownership shape the news you read.</p>
    <div class="scroll-down" onclick="document.querySelector('#bias-landscape').scrollIntoView({behavior: 'smooth'})">
      â†“
    </div>
  </section>

  <!-- Bias Landscape Overview with Distribution -->
  <section id="bias-landscape">
    <h2>Bias Landscape Overview</h2>
    <div class="dual-chart-container">
      <div class="chart-panel">
        <h3>Media Sources by Bias</h3>
        <svg id="landscape-chart" width="100%" height="500"></svg>
      </div>
      <div class="chart-panel">
        <h3 id="distribution-title">Bias Distribution: NDTV</h3>
        <svg id="distribution-chart" width="100%" height="500"></svg>
      </div>
    </div>
    <p>Click on any source in the left chart to see its bias distribution. Bubble size represents total story count.</p>
  </section>

  <!-- Source Ownership Insights -->
  <section id="source-ownership">
    <h2>Source Ownership Insights</h2>
    <div class="chart-container">
      <svg id="ownership-chart" width="100%" height="800"></svg>
    </div>
    <p>Treemap reveals the layers of ownership across news sources. Hover for details.</p>
  </section>

  <!-- Summary & Reflection -->
  <section id="summary">
    <h2>Summary & Reflection</h2>
    <p>Key Stats Recap: Mean bias, number of unique sources, most common owners.</p>
    <blockquote>"Every story has a storyteller. Bias isn't just what is said, but who says it, and who owns the voice."</blockquote>
    <button onclick="window.location.href='#'">Explore the Raw Data</button>
  </section>

  <!-- Main Script using ES6 Modules -->
  <script type="module">
    import * as d3 from "d3";

    // Animate counters using arrow functions
    const animateCounter = (selector, target) => {
      const el = document.querySelector(`${selector} span`);
      let count = 0;
      const increment = Math.ceil(target / 100);
      const interval = setInterval(() => {
        count += increment;
        if (count >= target) {
          count = target;
          clearInterval(interval);
        }
        el.textContent = count;
      }, 20);
    };

    window.addEventListener("load", () => {
      animateCounter("#total-articles", 63847);
      animateCounter("#total-stories", 6412);
      animateCounter("#num-sources", 3246);
    });

    // Intersection Observer for scroll-triggered animations
    const sections = document.querySelectorAll("section");
    const observerOptions = {
      threshold: 0.3
    };
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add("visible");
      });
    }, observerOptions);
    sections.forEach(section => observer.observe(section));

    // Create a tooltip for interactivity
    const tooltip = d3.select("body")
      .append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    // Function to update distribution chart
    const updateDistributionChart = (sourceName, biasDist) => {
      const distSvg = d3.select("#distribution-chart");
      distSvg.selectAll("*").remove();
      
      document.getElementById("distribution-title").textContent = `Bias Distribution: ${sourceName}`;
      
      const margin = {top: 40, right: 30, bottom: 50, left: 60};
      const width = distSvg.node().getBoundingClientRect().width - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;
      
      const g = distSvg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
      
      // Parse the bias distribution string into an array of numbers
      const distArray = biasDist.replace(/[\[\]]/g, "").split(",").map(Number);
      const categories = ["Left", "Center-Left", "Center", "Center-Right", "Right"];
      
      const x = d3.scaleBand()
        .domain(categories)
        .range([0, width])
        .padding(0.2);
      
      const y = d3.scaleLinear()
        .domain([0, d3.max(distArray)])
        .range([height, 0]);
      
      g.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end")
        .attr("dx", "-0.5em")
        .attr("dy", "0.5em");
      
      g.append("g")
        .call(d3.axisLeft(y));
      
      g.selectAll(".bar")
        .data(distArray)
        .enter()
        .append("rect")
        .attr("class", "distribution-bar")
        .attr("x", (d, i) => x(categories[i]))
        .attr("y", d => y(d))
        .attr("width", x.bandwidth())
        .attr("height", d => height - y(d))
        .on("mouseover", function(event, d, i) {
          d3.select(this).attr("fill", "#e15759");
          tooltip.transition().duration(200).style("opacity", 0.9);
          tooltip.html(`${d} articles`)
            .style("left", `${event.pageX + 10}px`)
            .style("top", `${event.pageY - 28}px`);
        })
        .on("mouseout", function() {
          d3.select(this).attr("fill", "#4e79a7");
          tooltip.transition().duration(500).style("opacity", 0);
        });
      
      g.append("text")
        .attr("x", width / 2)
        .attr("y", height + 40)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .text("Frequency of Articles by Bias Category");
    };

    // Load and process data
    d3.csv("dist/source_bias.csv", d3.autoType).then(data => {
      // Find NDTV data for initial distribution chart
      const ndtv = data.find(d => d.source_name.includes("NDTV")) || {
        source_name: "NDTV",
        bias_dist: "[5,15,20,20,20,15,5]"
      };
      updateDistributionChart(ndtv.source_name, ndtv.bias_dist);
      
      // Filter data for scatter plot
      const biasData = data.filter(d => d.topic_story_count > 120);
      
      const source_bias_colors = {
        "-3": "#0072B2",
        "-2": "#56B4E9",
        "-1": "#92C5DE",
        "0": "#D0D1D5",
        "1": "#F4A582",
        "2": "#CA0020",
        "3": "#D01719"
      };

      const scatterSvg = d3.select("#landscape-chart"),
        scatterMargin = {top: 20, right: 30, bottom: 70, left: 70},
        scatterWidth = scatterSvg.node().getBoundingClientRect().width - scatterMargin.left - scatterMargin.right,
        scatterHeight = 500 - scatterMargin.top - scatterMargin.bottom,
        scatterG = scatterSvg.append("g").attr("transform", `translate(${scatterMargin.left},${scatterMargin.top})`);

      const xScale = d3.scaleLinear()
        .domain(d3.extent(biasData, d => d.source_bias)).nice()
        .range([0, scatterWidth]);

      const yScale = d3.scaleLinear()
        .domain(d3.extent(biasData, d => d.mean_bias)).nice()
        .range([scatterHeight, 0]);

      const rScale = d3.scaleSqrt()
        .domain([0, d3.max(biasData, d => d.total_story_count)])
        .range([4, 35]);

      scatterG.append("g")
        .attr("transform", `translate(0,${scatterHeight})`)
        .call(
          d3.axisBottom(xScale)
            .tickValues([-2, -1, 0, 1, 2])
            .tickFormat(d => {
              return d === -2 ? "Left" : d === 2 ? "Right" : d;
            })
        );

      scatterG.append("g")
        .call(
          d3.axisLeft(yScale)
            .tickValues([-2, -1, 0, 1, 2])
            .tickFormat(d => {
              return d === -2 ? "Left" : d === 2 ? "Right" : d;
            })
        );

      // Axis labels
      scatterG.append("text")
        .attr("x", scatterWidth / 2)
        .attr("y", scatterHeight + 50)
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .text("Source Bias");

      scatterG.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -scatterHeight / 2)
        .attr("y", -50)
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .text("Mean Article Bias");

      const circles = scatterG.selectAll("circle")
        .data(biasData)
        .enter()
        .append("circle")
        .attr("cx", d => xScale(d.source_bias))
        .attr("cy", d => yScale(d.mean_bias))
        .attr("r", d => rScale(d.total_story_count))
        .attr("fill", d => source_bias_colors[d.source_bias] || "#999")
        .attr("opacity", 0.8)
        .on("mouseover", function(event, d) {
          d3.select(this)
            .attr("stroke-width", 2)
            .attr("stroke", "#000");
          tooltip.transition().duration(200).style("opacity", 0.9);
          tooltip.html(`<strong>${d.source_name}</strong><br/>Source Bias: ${d.source_bias}<br/>Mean Bias: ${d.mean_bias.toFixed(2)}<br/>Total Stories: ${Math.round(d.total_story_count)}`)
            .style("left", `${event.pageX + 10}px`)
            .style("top", `${event.pageY - 28}px`);
        })
        .on("mouseout", function() {
          if (!d3.select(this).classed("selected-circle")) {
            d3.select(this).attr("stroke-width", 0);
          }
          tooltip.transition().duration(500).style("opacity", 0);
        })
        .on("click", function(event, d) {
          // Remove selected class from all circles
          circles.classed("selected-circle", false)
            .attr("stroke-width", 0);
          
          // Add selected class to clicked circle
          d3.select(this)
            .classed("selected-circle", true)
            .attr("stroke-width", 3)
            .attr("stroke", "#000");
          
          // Update distribution chart
          updateDistributionChart(d.source_name, d.bias_dist || "[0,0,0,0,0,0,0]");
        });
      
      // Highlight NDTV initially if it exists in the data
      const ndtvCircle = circles.filter(d => d.source_name.includes("NDTV"));
      if (!ndtvCircle.empty()) {
        ndtvCircle.classed("selected-circle", true)
          .attr("stroke-width", 3)
          .attr("stroke", "#000");
      }

      // Prepare data for ownership treemap
      const ownershipData = {name: "Media Owners", children: []};
      const ownerMap = new Map();
      
      // Group sources by owner
      data.forEach(d => {
        if (d.source_owners && d.source_owners.trim() !== "") {
          const owners = d.source_owners.split(',').map(o => o.trim());
          owners.forEach(owner => {
            if (!ownerMap.has(owner)) {
              ownerMap.set(owner, {
                name: owner,
                value: 0,
                children: []
              });
            }
            const ownerNode = ownerMap.get(owner);
            ownerNode.value += d.total_story_count || 0;
            ownerNode.children.push({
              name: d.source_name,
              value: d.total_story_count || 0,
              source_bias: d.source_bias,
              mean_bias: d.mean_bias
            });
          });
        }
      });
      
      // Convert map to array and filter out owners with few sources
      ownerMap.forEach((value, key) => {
        if (value.children.length > 1 || value.value > 10000) {
          ownershipData.children.push(value);
        }
      });
      
      // Sort owners by total story count
      ownershipData.children.sort((a, b) => b.value - a.value);
      
      // Limit to top 20 owners for better visualization
      ownershipData.children = ownershipData.children.slice(0, 20);

      // Create ownership treemap
      const treemapSvg = d3.select("#ownership-chart"),
        treemapMargin = {top: 20, right: 20, bottom: 20, left: 20},
        treemapWidth = treemapSvg.node().getBoundingClientRect().width - treemapMargin.left - treemapMargin.right,
        treemapHeight = treemapSvg.node().getBoundingClientRect().height - treemapMargin.top - treemapMargin.bottom;

      const treemapG = treemapSvg.append("g")
        .attr("transform", `translate(${treemapMargin.left},${treemapMargin.top})`);

      const root = d3.hierarchy(ownershipData)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value);

      d3.treemap()
        .size([treemapWidth, treemapHeight])
        .padding(1)
        (root);

      // Color scale based on average bias
      const colorScale = d3.scaleLinear()
        .domain([-3, 0, 3])
        .range(["#0072B2", "#D0D1D5", "#CA0020"]);

      const nodes = treemapG.selectAll("g")
        .data(root.leaves())
        .enter()
        .append("g")
        .attr("transform", d => `translate(${d.x0},${d.y0})`);

      nodes.append("rect")
        .attr("width", d => d.x1 - d.x0)
        .attr("height", d => d.y1 - d.y0)
        .attr("fill", d => {
          // Use owner color for parent nodes, source color for leaves
          if (d.data.mean_bias !== undefined) {
            return source_bias_colors[Math.round(d.data.source_bias)] || "#666";
          }
          return colorScale(d.parent.data.mean_bias || 0);
        })
        .attr("stroke", "#fff")
        .on("mouseover", function(event, d) {
          d3.select(this).attr("stroke-width", 2);
          tooltip.transition().duration(200).style("opacity", 0.9);
          
          if (d.data.mean_bias !== undefined) {
            // It's a source
            tooltip.html(`<strong>${d.data.name}</strong><br/>Owner: ${d.parent.data.name}<br/>Stories: ${d.data.value}<br/>Source Bias: ${d.data.source_bias}<br/>Mean Bias: ${d.data.mean_bias?.toFixed(2) || 'N/A'}`)
              .style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 28}px`);
          } else {
            // It's an owner
            tooltip.html(`<strong>${d.data.name}</strong><br/>Total Stories: ${d.data.value}<br/>Sources: ${d.data.children?.length || 0}`)
              .style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 28}px`);
          }
        })
        .on("mouseout", function() {
          d3.select(this).attr("stroke-width", 0);
          tooltip.transition().duration(500).style("opacity", 0);
        });

      nodes.append("text")
        .attr("x", 4)
        .attr("y", 14)
        .text(d => d.data.name)
        .attr("class", "treemap-label")
        .attr("font-size", d => {
          // Dynamically adjust font size based on rectangle size
          const width = d.x1 - d.x0;
          const height = d.y1 - d.y0;
          const area = width * height;
          if (area < 1000) return "5px";
          if (area < 5000) return "10px";
          return "12px";
        })
        .call(wrap, d => d.x1 - d.x0 - 8);

      // Add title
      treemapG.append("text")
        .attr("x", treemapWidth / 2)
        .attr("y", -10)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .text("Media Ownership Structure (Top 20 Owners)");

      // Text wrapping function for treemap labels
      function wrap(text, widthFn) {
        text.each(function() {
          const text = d3.select(this);
          const words = text.text().split(/\s+/).reverse();
          const width = widthFn(text.datum());
          let word;
          let line = [];
          let lineNumber = 0;
          const lineHeight = 1.1; // ems
          const y = text.attr("y");
          const dy = parseFloat(text.attr("dy"));
          let tspan = text.text(null).append("tspan").attr("x", 4).attr("y", y).attr("dy", dy + "px");
          
          while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text.append("tspan").attr("x", 4).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "px").text(word);
            }
          }
        });
      }
    });
  </script>
</body>

</html>